using System;
using System.Collections.Generic;

namespace Discore
{
    /// <summary>
    /// Represents a message sent in a channel within Discord.
    /// </summary>
    public sealed class DiscordMessage : DiscordIdEntity
    {
        public const int MAX_CHARACTERS = 2000;

        /// <summary>
        /// Gets the ID of the channel this message is in.
        /// </summary>
        public Snowflake ChannelId { get; }
        /// <summary>
        /// Gets the author of this message.
        /// </summary>
        public DiscordUser Author { get; }
        /// <summary>
        /// If this message originated from a guild, gets the member properties of the author.
        /// <para/>
        /// Only available if this message originated from a MessageCreate or MessageUpdate Gateway event.
        /// </summary>
        public DiscordMessageMember Member { get; }
        /// <summary>
        /// Gets the contents of this message.
        /// </summary>
        public string Content { get; }
        /// <summary>
        /// Gets the time this message was first sent.
        /// </summary>
        public DateTime Timestamp { get; }
        /// <summary>
        /// Gets the time of the last edit to this message.
        /// </summary>
        public DateTime? EditedTimestamp { get; }
        /// <summary>
        /// Gets whether or not this message was sent with the /tts command.
        /// </summary>
        public bool TextToSpeech { get; }
        /// <summary>
        /// Gets whether or not this message mentioned everyone via @everyone.
        /// </summary>
        public bool MentionEveryone { get; }
        /// <summary>
        /// Gets a list of all user-specific mentions in this message.
        /// </summary>
        public IReadOnlyList<DiscordUser> Mentions { get; }
        /// <summary>
        /// Gets a list of all the IDs of mentioned roles in this message.
        /// </summary>
        public IReadOnlyList<Snowflake> MentionedRoleIds { get; }
        /// <summary>
        /// Gets a list of all channels mentioned in this message.
        /// May be null.
        /// <para/>
        /// Note: This will only ever be set for crossposted messages.
        /// </summary>
        public IReadOnlyList<DiscordChannelMention> MentionedChannels { get; }
        /// <summary>
        /// Gets a list of all attachments in this message.
        /// </summary>
        public IReadOnlyList<DiscordAttachment> Attachments { get; }
        /// <summary>
        /// Gets a list of all embedded attachments in this message.
        /// </summary>
        public IReadOnlyList<DiscordEmbed> Embeds { get; }
        /// <summary>
        /// Gets a list of all reactions to this message.
        /// </summary>
        public IReadOnlyList<DiscordReaction> Reactions { get; }
        /// <summary>
        /// Used for validating if a message was sent.
        /// </summary>
        public Snowflake? Nonce { get; }
        /// <summary>
        /// Gets whether or not this message is pinned in the containing channel.
        /// </summary>
        public bool IsPinned { get; }
        /// <summary>
        /// If this message was generated by a webhook, gets the ID of that webhook.
        /// </summary>
        public Snowflake? WebhookId { get; }
        /// <summary>
        /// Gets the type of message.
        /// </summary>
        public DiscordMessageType Type { get; }
        /// <summary>
        /// Gets the activity information for a Rich Presence-related chat message.
        /// </summary>
        public DiscordMessageActivity Activity { get; }
        /// <summary>
        /// Gets the application information for a Rich Persence-related chat message.
        /// </summary>
        public DiscordMessageApplication Application { get; }
        /// <summary>
        /// Gets the reference data sent with crossposted messages.
        /// </summary>
        public DiscordMessageReference MessageReference { get; }
        /// <summary>
        /// Flags describing extra features of the message.
        /// </summary>
        public DiscordMessageFlags Flags { get; }

        readonly DiscordApiData originalData;

        internal DiscordMessage(DiscordApiData data)
            : base(data)
        {
            originalData = data;

            Content         = data.GetString("content");
            Timestamp       = data.GetDateTime("timestamp").GetValueOrDefault();
            EditedTimestamp = data.GetDateTime("edited_timestamp").GetValueOrDefault();
            TextToSpeech    = data.GetBoolean("tts").GetValueOrDefault();
            MentionEveryone = data.GetBoolean("mention_everyone").GetValueOrDefault();
            Nonce           = data.GetSnowflake("nonce");
            IsPinned        = data.GetBoolean("pinned").GetValueOrDefault();
            ChannelId       = data.GetSnowflake("channel_id").GetValueOrDefault();
            WebhookId       = data.GetSnowflake("webhook_id");
            Type            = (DiscordMessageType)(data.GetInteger("type") ?? 0);
            Flags           = (DiscordMessageFlags)(data.GetInteger("flags") ?? 0);

            // Get author
            DiscordApiData authorData = data.Get("author");
            if (authorData != null)
                Author = new DiscordUser(WebhookId.HasValue, authorData);

            // Get member
            DiscordApiData memberData = data.Get("member");
            if (memberData != null)
                Member = new DiscordMessageMember(memberData);

            // Get activity
            DiscordApiData activityData = data.Get("activity");
            if (activityData != null)
                Activity = new DiscordMessageActivity(activityData);

            // Get application
            DiscordApiData applicationData = data.Get("application");
            if (applicationData != null)
                Application = new DiscordMessageApplication(applicationData);

            // Get reference
            DiscordApiData messageReferenceData = data.Get("message_reference");
            if (messageReferenceData != null)
                MessageReference = new DiscordMessageReference(messageReferenceData);

            // Get mentions
            IList<DiscordApiData> mentionsArray = data.GetArray("mentions");
            if (mentionsArray != null)
            {
                DiscordUser[] mentions = new DiscordUser[mentionsArray.Count];

                for (int i = 0; i < mentionsArray.Count; i++)
                    mentions[i] = new DiscordUser(false, mentionsArray[i]);

                Mentions = mentions;
            }

            // Get mentioned roles
            IList<DiscordApiData> mentionRolesArray = data.GetArray("mention_roles");
            if (mentionRolesArray != null)
            {
                Snowflake[] mentionedRoles = new Snowflake[mentionRolesArray.Count];

                for (int i = 0; i < mentionRolesArray.Count; i++)
                    mentionedRoles[i] = mentionRolesArray[i].ToSnowflake().Value;

                MentionedRoleIds = mentionedRoles;
            }

            // Get channel mentions
            IList<DiscordApiData> channelMentionsArray = data.GetArray("mention_channels");
            if (channelMentionsArray != null)
            {
                DiscordChannelMention[] mentions = new DiscordChannelMention[channelMentionsArray.Count];

                for (int i = 0; i < channelMentionsArray.Count; i++)
                    mentions[i] = new DiscordChannelMention(channelMentionsArray[i]);

                MentionedChannels = mentions;
            }

            // Get attachments
            IList<DiscordApiData> attachmentsArray = data.GetArray("attachments");
            if (attachmentsArray != null)
            {
                DiscordAttachment[] attachments = new DiscordAttachment[attachmentsArray.Count];

                for (int i = 0; i < attachmentsArray.Count; i++)
                    attachments[i] = new DiscordAttachment(attachmentsArray[i]);

                Attachments = attachments;
            }

            // Get embeds
            IList<DiscordApiData> embedsArray = data.GetArray("embeds");
            if (embedsArray != null)
            {
                DiscordEmbed[] embeds = new DiscordEmbed[embedsArray.Count];

                for (int i = 0; i < embedsArray.Count; i++)
                    embeds[i] = new DiscordEmbed(embedsArray[i]);

                Embeds = embeds;
            }

            // Get reactions
            IList<DiscordApiData> reactionsArray = data.GetArray("reactions");
            if (reactionsArray != null)
            {
                DiscordReaction[] reactions = new DiscordReaction[reactionsArray.Count];

                for (int i = 0; i < reactionsArray.Count; i++)
                    reactions[i] = new DiscordReaction(reactionsArray[i]);

                Reactions = reactions;
            }
        }

        /// <summary>
        /// Updates a message with a newer partial version of the same message. This is primarily used
        /// for obtaining the full message from a message update event, which only supplies the changes
        /// rather than the full message.
        /// </summary>
        /// <exception cref="ArgumentException">Thrown if the IDs of each message do not match.</exception>
        /// <exception cref="ArgumentNullException"></exception>
        public static DiscordMessage Update(DiscordMessage message, DiscordMessage withPartial)
        {
            if (message == null)
                throw new ArgumentNullException(nameof(message));
            if (withPartial == null)
                throw new ArgumentNullException(nameof(withPartial));

            if (message.Id != withPartial.Id)
                throw new ArgumentException("Cannot update one message with another. The message IDs must match.");

            DiscordApiData updatedData = message.originalData.Clone();
            updatedData.OverwriteUpdate(withPartial.originalData);

            return new DiscordMessage(updatedData);
        }
    }
}
